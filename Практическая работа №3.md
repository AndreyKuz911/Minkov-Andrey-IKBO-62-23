# Практическое занятие №3. Конфигурационные языки

Разобраться, что собой представляют программируемые конфигурационные языки (Jsonnet, Dhall, CUE).
## Задача 1

Реализовать на Jsonnet приведенный ниже пример в формате JSON. Использовать в реализации свойство программируемости и принцип DRY.

```
local student(name,age,group) = {
"age": age,
"name": name,
"group": group,
};
local groupN = "ИКБО-%g-%g";
{
groups: [
(groupN%[x,23]) for x in std.range(1,25)
],
students:[
student("Миньков А.И.",19,"ИКБО-4-23"),
student("Смирнов З.П.",18,"ИКБО-5-23"),
student("Макаров С.С.",19,"ИКБО-5-23"),
student("Калашников А.П.",18,"ИКБО-12-23"),
],
"subject": "Конфигурационное управление"
}
```
![image](https://github.com/user-attachments/assets/adc8942f-aa3f-443a-ac02-606c39803687)

![image](https://github.com/user-attachments/assets/bd0e2fc3-fb63-490b-b849-1ac1e43625f0)

![image](https://github.com/user-attachments/assets/052b74ee-d60a-46d1-bd13-bfed1f3398d8)


## Задача 2

Реализовать на Dhall приведенный ниже пример в формате JSON. Использовать в реализации свойство программируемости и принцип DRY.

```
let generate = https://prelude.dhall-lang.org/List/generate
let student = \(age: Natural) ->
\(group : Natural) -> \(name: Text) ->{
age = age,
group="ИКБО-"++ Natural/show group ++ "-23",
name = name}
let group = \(n: Natural) -> "ИКБО-"
++ Natural/show n ++ "-23"
let groups = generate 25 Text group
let student=[
student 19 4 "Миньков А.И.",
student 18 5 "Калашников М.П.",
student 18 12 "Кузнецов А.П."]
let subject = "Конфигурационное управление"
in {groups,student,subject}
```
![image](https://github.com/user-attachments/assets/9aeb51d7-c83b-43f6-94e6-ad331019a64a)

![image](https://github.com/user-attachments/assets/d447d1fd-1f05-4aea-816f-2357b62d7d0d)

![image](https://github.com/user-attachments/assets/92a59a05-c07f-4a8c-a6fc-2d4ce24126bf)


Для решения дальнейших задач потребуется программа на Питоне, представленная ниже. Разбираться в самом языке Питон при этом необязательно.

```Python
import random


def parse_bnf(text):
    '''
    Преобразовать текстовую запись БНФ в словарь.
    '''
    grammar = {}
    rules = [line.split('=') for line in text.strip().split('\n')]
    for name, body in rules:
        grammar[name.strip()] = [alt.split() for alt in body.split('|')]
    return grammar


def generate_phrase(grammar, start):
    '''
    Сгенерировать случайную фразу.
    '''
    if start in grammar:
        seq = random.choice(grammar[start])
        return ''.join([generate_phrase(grammar, name) for name in seq])
    return str(start)


BNF = '''
E = a
'''

for i in range(10):
    print(generate_phrase(parse_bnf(BNF), 'E'))

```

Реализовать грамматики, описывающие следующие языки (для каждого решения привести БНФ). Код решения должен содержаться в переменной BNF:

## Задача 3

Язык нулей и единиц.

```
import random

def parse_bnf(bnf_text):
    grammar_dict = {}
    rules = [line.split('=') for line in bnf_text.strip().split('\n')]
    for rule_name, rule_body in rules:
        grammar_dict[rule_name.strip()] = [option.split() for option in rule_body.split('|')]
    return grammar_dict

def create_phrase(grammar, start_symbol):
    if start_symbol in grammar:
        sequence = random.choice(grammar[start_symbol])
        return ''.join([create_phrase(grammar, symbol) for symbol in sequence])
    return str(start_symbol)

bnf_definition = '''
E = E "0" | E "1" | "0" | "1"
'''

for _ in range(10):
    print(create_phrase(parse_bnf(bnf_definition), 'E'))
```

![image](https://github.com/user-attachments/assets/c5bf543c-7399-494c-892f-3bcd350a4fb9)


## Задача 4

Язык правильно расставленных скобок двух видов.

```
import random

def parse_bnf(bnf_text):
    grammar_dict = {}
    rules = [line.split('=') for line in bnf_text.strip().split('\n')]
    for rule_name, rule_body in rules:
        grammar_dict[rule_name.strip()] = [alt.split() for alt in rule_body.split('|')]
    return grammar_dict

def create_phrase(grammar, start_symbol, max_depth=10, current_depth=0):
    if current_depth > max_depth:
        return ""
    if start_symbol in grammar:
        sequence = random.choice(grammar[start_symbol])
        return ''.join(create_phrase(grammar, symbol, max_depth, current_depth + 1) for symbol in sequence)
    return str(start_symbol)

bnf_definition = """
E = P E | F E | P | F 
P = "(" P ")" | "(" ")" 
F = "{" F "}" | "{}"
"""

for _ in range(10):
    phrase = create_phrase(parse_bnf(bnf_definition), 'E')
    if phrase:  
        print(phrase.replace('"', ''))  
```

![image](https://github.com/user-attachments/assets/61e1e817-f6bd-4aac-8b38-b7e8bbd89147)


## Задача 5

Язык выражений алгебры логики.

```
import random

def parse_bnf(bnf_text):
    # Создаем словарь для грамматики
    grammar_dict = {}
    # Разделяем текст на правила
    rules = [line.split('=') for line in bnf_text.strip().split('\n')]
    for rule_name, rule_body in rules:
        # Убираем лишние пробелы и создаем альтернативы
        grammar_dict[rule_name.strip()] = [alt.split() for alt in rule_body.split('|')]
    return grammar_dict

def create_phrase(grammar, start_symbol, max_depth=10, current_depth=0):
    # Проверяем максимальную глубину рекурсии
    if current_depth > max_depth:
        return ""
    if start_symbol in grammar:
        sequence = random.choice(grammar[start_symbol])
        return ''.join(create_phrase(grammar, symbol, max_depth, current_depth + 1) for symbol in sequence)
    return str(start_symbol)

# Определение грамматики в формате BNF
bnf_definition = """
E = L | E & L | E | E | E
L = x | y | "(" E ")" | "~" L | "(" E ")" | "~" L
"""

def format_generated_phrase(phrase):
    output = []
    previous_char = None
    open_parentheses_count = 0
    
    for char in phrase:
        if char in ['x', 'y']:
            if previous_char in ['x', 'y']:
                continue
            output.append(char)
        elif char in ['&', '|']:
            if len(output) < 2 or output[-1] in ['&', '|'] or (previous_char in ['(', ')']):
                continue
            output.append(char)
        elif char == '(':
            if previous_char == '(':
                continue
            output.append(char)
            open_parentheses_count += 1
        elif char == ')':
            if output and output[-1] == '(':
                output.pop()
                open_parentheses_count -= 1
                continue
            if open_parentheses_count > 0:
                output.append(char)
                open_parentheses_count -= 1

        previous_char = char

    # Убираем лишние открывающие скобки
    output = [c for c in output if not (c == '(' and (previous_char == '(' or (len(output) > 1 and output[-2] == '(')))]

    return ''.join(output)

# Генерация и вывод 10 случайных фраз
for _ in range(10):
    generated_phrase = create_phrase(parse_bnf(bnf_definition), 'E')
    if generated_phrase:
        formatted_phrase = format_generated_phrase(generated_phrase)
        if formatted_phrase:
            print(formatted_phrase.replace('"', ''))  # Убираем кавычки
```

![image](https://github.com/user-attachments/assets/50944d92-6f2f-4cdf-9b5a-bb64504c4644)
